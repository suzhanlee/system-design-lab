# ADR-003. 접속 통계 저장 방식 선택

## Metadata
| 항목 | 값 |
|------|-----|
| 작성자 | Claude (AI Pair Programmer) |
| 작성일 | 2026-02-27 |
| 검토일 | 2026-08-27 (+6개월) |
| Status | Proposed |

---

## Pre-Mortem (Phase A 결과)

### Q1: 이 결정이 1년 후 실패한다면 가장 가능성 높은 이유는?
- **Redis 장애 시 통계 유실**: Redis 다운 중 발생한 조회수가 DB에 반영되지 않음
- **동기화 스케줄러 장애**: 스케줄러가 멈추면 Redis 카운터가 DB로 영구 저장되지 않음
- **Redis 메모리 부족**: 조회수 카운터가 메모리를 과도하게 점유하여 OOM 발생

### Q2: 실패 당시 상황

| 항목 | 현재 (MVP) | 실패 시나리오 |
|------|------------|---------------|
| 일일 리다이렉트 | 10만 건 | 1,000만 건 |
| 조회수 업데이트 | 10만 회/일 | 1,000만 회/일 |
| 조회수 조회 | 1천 회/일 | 10만 회/일 |
| Redis 메모리 | 4GB | 32GB |
| 통계 유실 허용 | ✓ | 100% 정확도 불필요 |

### Q3: 미리 알았다면 다른 선택

| 조건 | 다른 선택 | 이유 |
|------|-----------|------|
| Redis 장애가 빈번하다면 | DB 직접 저장 | 유실 최소화 |
| 통계가 100% 정확해야 한다면 | DB 직접 저장 | 정합성 보장 |
| DAU가 100만을 넘는다면 | Kafka + ELK | 대규모 처리 |

### 핵심 설계 결정
- **Circuit Breaker**: Redis 장애 시 DB로 폴백
- **복구 전략**: Cache 무효화 + Cache Warm-up
- **동기화**: 스케줄러로 1시간마다 Bulk 연산
- **정합성**: 100% 불필요, 유실 어느 정도 허용

---

## Context

### 비즈니스 요구사항
- **URL별 조회수 카운팅**: 해당 URL이 몇 번 조회되었는지 추적
- **Write-Heavy 패턴**: 리다이렉트마다 조회수 +1 (쓰기 많음, 읽기 적음)
- **통계 정확도**: 100% 정확하지 않아도 됨 (유실 어느 정도 허용)
- **리다이렉트 성능 유지**: 100ms 목표 달성을 위해 조회수 업데이트가 병목이 되어서는 안 됨

### 기술적 제약사항
- Java / Spring Boot / JPA 사용
- Redis 이미 캐싱 용도로 사용 중 (ADR-002)
- 스케줄러 사용 가능 (Spring Scheduler)

### 왜 지금 결정해야 하는가?
- ADR-002(캐싱 전략) 결정 이후 조회수 저장 방식 수립 필요
- 리다이렉트 성능에 직접적인 영향을 미치는 요소
- 인프라 복잡도와 비용에 큰 영향

---

## Decision

**Redis INCR + 주기적 DB 동기화 (1시간 Bulk)** 방식을 선택한다.

### 구체적 구현 방식
```
1. 리다이렉트 발생 → Redis INCR (url:shortCode:views)
2. 조회수 조회 → Redis GET (있으면 반환, 없으면 DB 조회)
3. 1시간마다 스케줄러 실행 → Redis 전체 스캔 → DB Bulk UPDATE
4. Redis 장애 시 → Circuit Breaker → DB 직접 UPDATE
5. Redis 복구 시 → Cache 무효화 + Cache Warm-up (DB → Redis)
```

### 선택한 이유
- **Write-Heavy 최적화**: Redis INCR은 초당 수만 건 처리 가능
- **100ms 목표 유지**: Redis INCR은 1ms 이내 완료
- **유실 허용**: 1시간 동기화 주기로 성능 확보, 일부 유실 감수
- **단순한 인프라**: Kafka/ELK 없이 Redis + 스케줄러로 구현

---

## Trade-off Matrix (Phase B 결과)

| 평가기준 | Redis INCR + 동기화 (선택) | DB 직접 저장 | Kafka + ELK |
|----------|---------------------------|--------------|-------------|
| 쓰기 속도 | ⭐⭐⭐⭐⭐ (5) | ⭐⭐ (2) | ⭐⭐⭐⭐⭐ (5) |
| 데이터 유실 방지 | ⭐⭐⭐ (3) | ⭐⭐⭐⭐⭐ (5) | ⭐⭐⭐⭐ (4) |
| 구현 복잡도 | ⭐⭐⭐⭐ (4) | ⭐⭐⭐⭐⭐ (5) | ⭐⭐ (2) |
| 인프라 비용 | ⭐⭐⭐⭐ (4) | ⭐⭐⭐⭐⭐ (5) | ⭐⭐ (2) |
| 장애 대응 | ⭐⭐⭐⭐ (4) | ⭐⭐⭐⭐⭐ (5) | ⭐⭐⭐ (3) |
| **총점** | **20** | **22** | **16** |

### 선택 설명 (트레이드오프)
Redis INCR + 동기화 방식은 총점 20점으로 DB 직접 저장(22점)보다 낮지만, **쓰기 속도**에서 압도적 우위(5 vs 2)를 보인다.

**트레이드오프 분석:**
- DB 직접 저장은 정합성이 좋지만, 리다이렉트마다 DB UPDATE → 100ms 목표 실패 가능
- Kafka + ELK는 확장성이 좋지만, 인프라 복잡도와 비용이 크게 증가
- **Write-Heavy 패턴**에서는 쓰기 속도가 핵심 → Redis INCR 선택

**DB 직접 저장을 선택하지 않은 이유:**
- 리다이렉트마다 `UPDATE url SET views = views + 1` 실행
- DB 쓰기 10만 회/일 → 1,000만 회/일 시 DB 병목 확실
- 100ms 목표 달성 불가능

---

## Alternatives Considered

### Redis INCR + 주기적 DB 동기화 (선택)
- **장점**:
  - 초당 수만 건 쓰기 처리 가능 (Redis INCR)
  - 리다이렉트 성능 영향 없음 (~1ms)
  - 단순한 인프라 (Redis + 스케줄러)
  - Circuit Breaker로 장애 대응 가능
- **단점**:
  - 최대 1시간치 통계 유실 가능 (Redis 장애 시)
  - 동기화 스케줄러가 SPOF
  - Redis 메모리 사용량 증가
- **완화 전략**:
  - Circuit Breaker: Redis 장애 시 DB로 폴백
  - Cache Warm-up: 복구 시 DB에서 Redis로 재동기화
  - 동기화 주기 조정: 트래픽에 따라 30분/1시간 선택

### DB 직접 저장
- **장점**:
  - 데이터 유실 없음 (100% 정합성)
  - 구현이 가장 단순함
  - 외부 의존성 없음
- **단점**:
  - 리다이렉트마다 DB UPDATE → 성능 병목
  - DB 쓰기 부하 급증
  - 100ms 목표 달성 어려움
- **선택하지 않은 이유**:
  - 쓰기 속도 점수가 2점으로 낮음
  - Write-Heavy 패턴에 부적합
- **실패 시나리오**:
  - 리다이렉트 응답 시간 500ms+ 증가
  - DB 커넥션 풀 고갈

### Kafka + ELK (로그 분석)
- **장점**:
  - 대규모 트래픽 처리 가능
  - 통계 분석 기능 강력
  - 실시간 스트리밍 가능
- **단점**:
  - 인프라 복잡도 매우 높음 (Kafka, Zookeeper, ELK)
  - 운영 비용 크게 증가
  - 팀 규모가 작을 때 운영 부담
- **선택하지 않은 이유**:
  - 현재 규모(DAU 10만)에 과도한 설계
  - 구현 복잡도 점수가 2점으로 낮음
- **재고 시점**: DAU 100만 도달 시 검토

---

## Consequences

### 긍정적
- **리다이렉트 성능 유지**: Redis INCR은 1ms 이내 완료
- **간단한 인프라**: Redis + 스케줄러만으로 구현
- **확장성**: 트래픽 증가 시 동기화 주기만 조정하면 됨
- **장애 대응**: Circuit Breaker로 우아한 성능 저하

### 부정적
- **통계 유실 가능**: Redis 장애 시 최대 1시간치 데이터 손실
- **정합성 지연**: DB 기준 통계는 최대 1시간 뒤에 반영
- **운영 포인트 추가**: 동기화 스케줄러 모니터링 필요

### 위험
- **동기화 스케줄러 장애**
  - **완화 전략**: 스케줄러 헬스체크, 장애 시 알림
- **Redis OOM**
  - **완화 전략**: 조회수 키에도 TTL 설정 (7일), 메모리 모니터링
- **대량 유실 시 사용자 불만**
  - **완화 전략**: "실제 조회수와 다를 수 있음" 안내 문구

---

## Reconsideration Trigger

### 재검토 조건 (정량적 임계값)

| 조건 | 임계값 | 현재 상태 | 재검토 필요 |
|------|--------|-----------|-------------|
| 일일 리다이렉트 | 500만 건 | 10만 건 | ❌ |
| Redis 메모리 사용률 | 80% 초과 | ~50% | ❌ |
| 동기화 소요 시간 | 10분 초과 | ~1분 | ❌ |
| 통계 정확도 요구 | 99% 이상 | 95% 목표 | ❌ |
| DAU | 100만 | 10만 | ❌ |

**재검토 시점**: 2026-08-27 (6개월 후) 또는 위 임계값 도달 시

### 재검토 시 고려사항
- DAU 100만 도달 시 Kafka + ELK 도입 검토
- 통계 정확도 99% 요구 시 동기화 주기 단축 (30분 → 5분)
- Redis OOM 빈발 시 DB 직접 저장 하이브리드 방식 검토

---

## Self-Critique Score (Phase D 결과)

| # | 항목 | 점수(1~5) | 비고 |
|---|------|-----------|------|
| 1 | Context 충분성 | 5 | 6개월 후 이해 가능 |
| 2 | 대안 분석 깊이 | 4 | 3가지 대안 심도 있게 분석 |
| 3 | Consequences 솔직성 | 5 | 유실 가능성 명시, 완화 전략 포함 |
| 4 | Reconsideration 구체성 | 5 | 재검토 조건 명확 |
| 5 | 설득력 | 4 | DB 직접 저장보다 점수 낮지만 이유 설명 |
| **총점** | | **23/25** | **평균 4.6** |

**평균 4점 미만 항목은 수정 완료**: [x] 예 [ ] 아니오

---

## Related
- Related ADRs: ADR-001 (단축 URL 생성 알고리즘), ADR-002 (캐싱 전략)
- Related Requirements: 조회수 통계, 리다이렉트 100ms

## References
- [Redis INCR](https://redis.io/commands/incr/)
- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html)
- [Spring Scheduler](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#scheduling)
