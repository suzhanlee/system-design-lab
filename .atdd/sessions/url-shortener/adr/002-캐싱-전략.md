# ADR-002. 캐싱 전략 선택

## Metadata
| 항목 | 값 |
|------|-----|
| 작성자 | Claude (AI Pair Programmer) |
| 작성일 | 2026-02-27 |
| 검토일 | 2026-08-27 (+6개월) |
| Status | Proposed |

---

## Pre-Mortem (Phase A 결과)

### Q1: 이 결정이 1년 후 실패한다면 가장 가능성 높은 이유는?
- **캐시 히트율 저하**: short URL 생성 시마다 캐시 무효화로 인해 캐시 효과 미미
- **메모리 낭비**: Write-Through 방식 사용 시 조회되지 않는 URL까지 캐시에 저장하여 메모리 비효율
- **데이터 일관성 문제**: 로컬 캐시 사용 시 분산 환경에서 캐시 동기화 실패

### Q2: 실패 당시 상황
| 항목 | 현재 | 실패 시나리오 |
|------|------|---------------|
| 트래픽 | DAU 10만 | DAU 100만 |
| 캐시 적중률 | 목표 95% | 50% 이하 |
| 응답시간 | 100ms 목표 | 500ms+ |
| Redis 메모리 | 4GB | 32GB 초과 |

### Q3: 미리 알았다면 다른 선택
- 만약 **대부분의 URL이 반복 조회된다**는 것을 알았다면 → **Write-Through** 방식을 고려했을 것
- 만약 **단일 서버 환경**이라는 것을 알았다면 → **로컬 캐시(Caffeine)** 방식을 고려했을 것
- 만약 **메모리 제약이 심하다**는 것을 알았다면 → **TTL을 더 짧게 설정**했을 것

---

## Context

### 비즈니스 요구사항
- **리다이렉트 응답 시간: 100ms 이내** (핵심 성능 지표)
- DAU 10만 규모 지원 (중간 규모 트래픽)
- 개인 URL 단축 서비스 → 각 사용자가 서로 다른 URL 생성 (Long-tail 분포)

### 기술적 제약사항
- Java / Spring Boot 사용
- 캐싱: Redis (분산 환경 지원 필수)
- ADR-001에서 선택한 Hash+Sequence 알고리즘 사용
- 같은 URL은 항상 같은 단축 URL 생성 (멱등성)

### 왜 지금 결정해야 하는가?
- ADR-001(단축 URL 생성 알고리즘) 결정 이후 캐싱 전략 수립 필요
- 리다이렉트 성능(100ms 목표) 달성을 위해 캐싱 필수
- 캐싱 전략에 따라 인프라 비용과 복잡도가 크게 달라짐

---

## Decision

**Redis Look-Aside + TTL (24시간)** 방식을 선택한다.

### 구체적 구현 방식
```
1. 리다이렉트 요청 → Redis 조회
2. Hit → 바로 반환 (1ms)
3. Miss → DB 조회 → Redis 저장 (TTL 24h) → 반환 (~50ms)
4. 24시간 후 자동 만료 → 안 쓰는 URL은 자연스럽게 제거
```

### 선택한 이유
- **Long-tail 분포 대응**: 개인 URL 단축 → 각자 다른 URL → 실제 조회되는 것만 캐시
- **메모리 효율**: Write-Through는 조회 안 될 URL도 캐시에 저장 (낭비)
- **100ms 목표 달성**: Look-Aside로도 캐시 히트 시 1ms 달성 가능

---

## Trade-off Matrix (Phase B 결과)

| 평가기준 | Look-Aside+TTL (선택) | Write-Through | 로컬 캐시 |
|----------|----------------------|---------------|-----------|
| 리다이렉트 속도 | ⭐⭐⭐⭐ (4) | ⭐⭐⭐⭐⭐ (5) | ⭐⭐⭐⭐⭐ (5) |
| 캐시 적중률 유지 | ⭐⭐⭐⭐ (4) | ⭐⭐⭐⭐⭐ (5) | ⭐⭐⭐⭐⭐ (5) |
| 메모리 효율 | ⭐⭐⭐⭐⭐ (5) | ⭐⭐⭐ (3) | ⭐⭐⭐⭐ (4) |
| 분산 환경 지원 | ⭐⭐⭐⭐ (4) | ⭐⭐⭐⭐ (4) | ❌ (0) |
| 데이터 일관성 | ⭐⭐⭐⭐⭐ (5) | ⭐⭐⭐⭐⭐ (5) | ⭐⭐⭐⭐ (4) |
| 구현 복잡도 | ⭐⭐⭐ (3) | ⭐⭐⭐ (3) | ⭐ (1) |
| **총점** | **25** | **23** | **15** |

### 선택 설명 (트레이드오프)
Look-Aside+TTL 방식은 총점 25점으로 가장 높으며, 특히 **메모리 효율**과 **분산 환경 지원**에서 균형 잡힌 점수를 보인다.

**트레이드오프 분석:**
- Write-Through보다 메모리 효율이 높음 (5 vs 3) - 조회되지 않는 URL은 캐시에 저장하지 않음
- 로컬 캐시보다 분산 환경 지원이 우수함 (4 vs 0) - 여러 서버 간 캐시 공유 가능
- 리다이렉트 속도는 약간 느리지만, 캐시 히트 시 1ms로 목표(100ms) 달성 가능

---

## Alternatives Considered

### Redis Look-Aside + TTL (선택)
- **장점**:
  - 실제 조회되는 URL만 캐시에 저장 → 메모리 효율
  - TTL로 자동 만료 → 안 쓰는 URL 자연스럽게 제거
  - 분산 환경 지원 → 여러 서버 간 캐시 공유
  - 구현이 상대적으로 단순함
- **단점**:
  - 첫 조회 시 DB 조회 필요 (Cache Miss 페널티)
  - 캐시 워밍업 시간 필요
- **실패 시나리오**:
  - 캐시 히트율이 예상보다 낮은 경우 (반복 조회가 적은 경우)
  - Redis 장애 시 DB 부하 급증

### Write-Through
- **장점**:
  - 항상 캐시에 데이터 존재 → 첫 조회도 빠름
  - 캐시 적중률 100% 보장
  - DB와 캐시 간 일관성 보장
- **단점**:
  - 조회되지 않는 URL도 캐시에 저장 → 메모리 낭비
  - 쓰기 작업 시 캐시 업데이트 오버헤드
  - Long-tail 분포에서 메모리 비효율
- **선택하지 않은 이유**:
  - 메모리 효율 점수가 낮음 (3점)
  - 개인 URL 단축 서비스 특성상 대부분의 URL이 반복 조회되지 않음
- **실패 시나리오**:
  - 캐시 메모리 급증으로 인한 비용 폭증
  - Redis OOM (Out of Memory) 발생

### 로컬 캐시 (Caffeine/Guava Cache)
- **장점**:
  - 네트워크 오버헤드 없음 → 가장 빠른 응답 속도
  - 구현이 가장 단순함
  - 외부 의존성 없음
- **단점**:
  - 분산 환경에서 캐시 동기화 불가
  - 서버 간 데이터 불일치 발생
  - 서버 재시작 시 캐시 손실
- **선택하지 않은 이유**:
  - 분산 환경 지원 점수가 0점
  - 여러 서버 운영 시 캐시 일관성 보장 불가
- **실패 시나리오**:
  - 서버 확장 시 캐시 효율 급감
  - 사용자가 다른 서버로 요청 시 캐시 미스

---

## Consequences

### 긍정적
- **메모리 효율**: 실제 조회되는 URL만 캐시에 저장
- **자동 정리**: TTL 24시간으로 안 쓰는 URL 자동 제거
- **분산 확장**: 여러 서버에서 동일한 캐시 공유
- **목표 달성**: 캐시 히트 시 1ms 응답으로 100ms 목표 달성

### 부정적
- **첫 조회 지연**: Cache Miss 시 DB 조회 필요 (~50ms)
- **Redis 의존성**: Redis 장애 시 성능 저하
- **캐시 워밍업**: 서비스 시작 직후 캐시 히트율 낮음

### 위험
- **Redis 장애 시 DB 부하 급증**
  - **완화 전략**: Circuit Breaker 패턴 적용, Redis 장애 시 DB 직접 조회로 폴백
- **캐시 스탬피드 (Cache Stampede)**
  - **완화 전략**: Cache-Aside + TTL 갱신 시 랜덤 딜레이 적용

---

## Reconsideration Trigger

### 재검토 조건 (정량적 임계값)

| 조건 | 임계값 | 현재 상태 | 재검토 필요 |
|------|--------|-----------|-------------|
| 캐시 적중률 | 80% 미만 | 목표 95% | ❌ |
| Redis 메모리 사용률 | 80% 초과 | ~50% | ❌ |
| 리다이렉트 P99 응답시간 | 150ms 초과 | ~100ms | ❌ |
| DAU | 50만 | 10만 | ❌ |

**재검토 시점**: 2026-08-27 (6개월 후) 또는 위 임계값 도달 시

### 재검토 시 고려사항
- 캐시 적중률 80% 미만 시 Write-Through 방식 검토
- DAU 50만 도달 시 Redis 클러스터링 검토
- 메모리 사용률 80% 초과 시 TTL 단축 또는 캐시 용량 증설

---

## Self-Critique Score (Phase D 결과)

| # | 항목 | 점수(1~5) | 비고 |
|---|------|-----------|------|
| 1 | Context 충분성 | 5 | 6개월 후 이해 가능 |
| 2 | 대안 분석 깊이 | 4 | 3가지 대안 심도 있게 분석 |
| 3 | Consequences 솔직성 | 4 | 부정적 결과 포함 |
| 4 | Reconsideration 구체성 | 5 | 재검토 조건 명확 |
| 5 | 설득력 | 4 | 반론 대응 가능 |
| **총점** | | **22/25** | **평균 4.4** |

**평균 4점 미만 항목은 수정 완료**: [x] 예 [ ] 아니오

---

## Related
- Related ADRs: ADR-001 (단축 URL 생성 알고리즘), ADR-003 (접속 통계 저장 방식)
- Related Requirements: 리다이렉트 100ms, 캐싱 전략

## References
- [Redis Caching Patterns](https://redis.io/docs/manual/client-side-caching/)
- [Cache-Aside Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside)
- [Caffeine Cache](https://github.com/ben-manes/caffeine)
