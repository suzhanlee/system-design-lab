# ADR Pre-Mortem Questions Guide

## 개요

Pre-Mortem은 ADR 작성 전에 "이 결정이 실패했다고 가정하고" 실패 원인을 미리 식별하는 기법이다.
Gary Klein이 개발한 이 방법은 Hindsight Bias(후견편향)를 역이용하여 잠재적 위험을 사전에 발견한다.

---

## 핵심 질문 (Phase A)

### Q1: 이 결정이 1년 후 실패한다면 가장 가능성 높은 이유는?

**목적**: 실패의 근본 원인(Root Cause)을 미리 식별

**답변 가이드**:
- 구체적이고 관찰 가능한 현상으로 작성
- "성능이 느려진다" (X) → "API 응답 시간이 500ms를 초과한다" (O)
- "유지보수가 어렵다" (X) → "새로운 기능 추가 시 3개 이상의 파일 수정이 필요하다" (O)

**예시 답변**:
```
Redis를 세션 저장소로 선택한 경우:
- 세션 데이터 크기가 예상보다 10배 커져서 메모리 부족 발생
- Redis 장애 시 전체 서비스 로그아웃 발생
- 세션 TTL 관리 로직이 복잡해져서 버그 발생
```

---

### Q2: 실패 당시 상황은? (트래픽, 팀 규모, 비즈니스 변화)

**목적**: 결정이 실패하게 되는 Context를 구체화

**답변 항목**:

| 항목 | 현재 상황 | 실패 시나리오 |
|------|-----------|---------------|
| 트래픽 | DAU 1,000 | DAU 100,000 |
| 팀 규모 | 3명 | 15명 |
| 데이터 크기 | 10GB | 1TB |
| 비즈니스 | 단일 서비스 | 멀티 테넌트 |
| 요구사항 | CRUD | 실시간 분석 |

**예시 답변**:
```
MySQL 선택한 경우:
- 트래픽: 현재 DAU 5,000 → 실패 시 DAU 200,000 (40배 증가)
- 팀 규모: 현재 2명 → 실패 시 20명 (신규 팀원들이 MySQL 운영 경험 부족)
- 비즈니스: 현재 B2C → 실패 시 B2B 엔터프라이즈 (SLA 99.99% 요구)
```

---

### Q3: 미리 알았다면 어떤 다른 선택을 했을까?

**목적**: 현재 결정의 약점을 보완할 대안 탐색

**답변 가이드**:
- "만약 X를 알았다면 Y를 선택했을 것이다" 형식으로 작성
- 구체적인 조건과 대안을 명시

**예시 답변**:
```
MySQL 선택한 경우:
- 만약 "읽기보다 쓰기가 10배 많을 것"을 알았다면 → Cassandra 고려했을 것
- 만약 "6개월 내 멀티 리전 필요"를 알았다면 → PostgreSQL + 논리적 복제 고려했을 것
- 만약 "팀의 MySQL DBA 채용이 어려울 것"을 알았다면 → Managed DB(RDS) 사용 고려했을 것
```

---

## 분야별 Pre-Mortem 예시

### 데이터베이스 선택

```markdown
Q1. 실패 이유:
- 쿼리 복잡도 증가로 인한 성능 저하
- 스키마 변경 시 서비스 중단 발생
- 백업/복구 시간이 RTO 초과

Q2. 실패 상황:
- 데이터: 100GB → 5TB
- 쿼리: 단순 조회 → 복잡한 집계 (5개 테이블 조인)
- 운영: 개발자 DBA → 전담 DBA 없음

Q3. 다른 선택:
- PostgreSQL: JSONB와 복잡한 쿼리 지원이 필요했다면
- MongoDB: 스키마 유연성이 중요했다면
```

### 인증 방식 선택

```markdown
Q1. 실패 이유:
- JWT 토큰 폐기 불가능으로 인한 보안 사고
- Refresh Token 탈취로 인한 장기간 접근
- OAuth 프로바이더 장애 시 서비스 전체 마비

Q2. 실패 상황:
- 사용자: 내부 직원 → 외부 사용자 100만 명
- 보안 요구: 일반 → PCI-DSS 준수
- 디바이스: PC → IoT 디바이스 포함

Q3. 다른 선택:
- Session + Redis: 토큰 폐기가 중요했다면
- OIDC: 표준 프로토콜 준수가 중요했다면
```

### API 아키텍처 선택

```markdown
Q1. 실패 이유:
- N+1 쿼리 문제로 인한 API 응답 지연
- GraphQL 스키마 관리 복잡도 증가
- 프론트엔드 팀의 학습 곡선으로 인한 일정 지연

Q2. 실패 상황:
- API 수: 20개 → 200개
- 클라이언트: 단일 웹 → 웹/앱/IoT/파트너
- 팀: 풀스택 3명 → FE/BE 분리 10명

Q3. 다른 선택:
- REST: 표준화와 캐싱이 중요했다면
- gRPC: 마이크로서비스 간 통신이었다면
```

### 메시지 큐 선택

```markdown
Q1. 실패 이유:
- 메시지 순서 보장 실패로 인한 비즈니스 로직 오류
- 메시지 유실로 인한 데이터 불일치
- 큐 장애 시 생산자 서비스 블로킹

Q2. 실패 상황:
- 메시지: 1,000개/일 → 1,000만 개/일
- 패턴: 단순 작업 큐 → 이벤트 소싱
- 의존성: 선택적 → 필수 (장애 시 서비스 중단)

Q3. 다른 선택:
- Kafka: 메시지 순서와 영속성이 중요했다면
- SQS: 운영 부담 감소가 중요했다면
```

---

## Pre-Mortem 체크리스트

Pre-Mortem 답변이 충분한지 확인:

- [ ] **구체성**: 추상적 표현 없이 측정 가능한 실패 조건이 있는가?
- [ ] **현실성**: 실제 발생 가능한 시나리오인가?
- [ ] **다양성**: 기술/운영/비즈니스 관점이 모두 포함되었는가?
- [ ] **대안 연결**: Q3의 대안이 Q1의 실패 원인을 해결하는가?
- [ ] **재검토 가능**: 나중에 "이 결정이 맞았는가?" 판단할 수 있는가?

---

## 참조

- Gary Klein, "Performing a Project Premortem" (Harvard Business Review, 2007)
- "Thinking, Fast and Slow" - Daniel Kahneman (Hindsight Bias)
